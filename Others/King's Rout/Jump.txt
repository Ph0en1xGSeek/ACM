这题是个交互题，后台有个长度为偶数n的01串s，让你猜这个串，然后看有多少位对应相同，当只有n/2,n个相同的时候返回n/2,n,否则都是返回0，让你最多用n+500猜，猜到正确答案
这个构造真的好难啊，首先要找到返回n/2的串，然后对于这个串，假设第一位是正确的，然后把第一位取反，然后枚举后面的位数，每次将一位取反后，看返回n/2还是0，如果返回n/2，表明这会这一位是假设正确，否则，取反之前的这一位是正确的,这样就找到了第一位和第i位的正确关系，最后把每一位都改成对应正确的位，看返回0还是n，如果是0就再全部取反
上述的操作，需要最多n?1+1+1=n+1次,那么必须在499次内，就找到n/2的串 
开头一直想的枚举，就是搞不出来，因为复杂度最坏是O(n)的，GG 
其实这题应该打表找规律，随便取一个s，然后随机生成一个01串，和s有n/2位相同的概率大约0.02，大约50次就能得到，这样就能够在范围内构造出n/2的串了


#include <map>
#include <set>
#include <ctime>
#include <stack>
#include <queue>
#include <cmath>
#include <string>
#include <vector>
#include <cstdio>
#include <cctype>
#include <cstring>
#include <sstream>
#include <cstdlib>
#include <iostream>
#include <algorithm>

using namespace std;
#define   MAX           1000005
#define   MAXN          1000005
#define   maxnode       205
#define   sigma_size    26
#define   lson          l,m,rt<<1
#define   rson          m+1,r,rt<<1|1
#define   lrt           rt<<1
#define   rrt           rt<<1|1
#define   middle        int m=(r+l)>>1
#define   LL            long long
#define   ull           unsigned long long
#define   mem(x,v)      memset(x,v,sizeof(x))
#define   lowbit(x)     (x&-x)
#define   pii           pair<int,int>
#define   bits(a)       __builtin_popcount(a)
#define   mk            make_pair
#define   limit         10000

//const int    prime = 999983;
const int    INF   = 0x3f3f3f3f;
const LL     INFF  = 0x3f3f;
const double pi    = acos(-1.0);
const double inf   = 1e18;
const double eps   = 1e-4;
const LL    mod    = 772002;
const ull    mx    = 133333331;

/*****************************************************/
inline void RI(int &x) {
      char c;
      while((c=getchar())<'0' || c>'9');
      x=c-'0';
      while((c=getchar())>='0' && c<='9') x=(x<<3)+(x<<1)+c-'0';
 }
/*****************************************************/

int now[1005];
int vis[1005];
int main(){
    //freopen("froggy.in","r",stdin);
    //freopen("froggy.out","w",stdout);
    int n;
    cin>>n;
    srand(time(NULL));
    while(1){
        for(int i=1;i<=n;i++) now[i]=rand()%2;
        for(int i=1;i<=n;i++) printf("%d",now[i]);
        cout<<endl;
        int t;
        cin>>t;
        if(t==n) return 0;
        if(t==n/2) break;
    }
    vis[1]=now[1];
    now[1]=!now[1];
    for(int i=2;i<=n;i++){
        now[i]=!now[i];
        for(int j=1;j<=n;j++) printf("%d",now[j]);
        cout<<endl;
        int t;
        cin>>t;
        if(t==n/2) vis[i]=now[i];
        else vis[i]=!now[i];
        now[i]=!now[i];
    }
    for(int i=1;i<=n;i++) printf("%d",vis[i]);
    cout<<endl;
    int t;
    cin>>t;
    if(t==n) return 0;
    for(int i=1;i<=n;i++) printf("%d",!vis[i]);
    cout<<endl;
    return 0;
}